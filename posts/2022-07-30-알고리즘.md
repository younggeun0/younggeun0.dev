---
title: 알고리즘 문제풀이 - 신고 결과 받기 (JS)
project: false
date: 2022-07-30
---


### [프로그래머스 > 코딩테스트 연습 > 2022 KAKAO BLIND RECRUITMENT > 신고 결과 받기](https://school.programmers.co.kr/learn/courses/30/lessons/92334)

### 내 풀이

- 테스트 케이스 일부에서 시간 초과 발생 (66.7점)
- 마지막 3번 과정에서 blockedUser에 포함 여부를 확인하는 이중 for문이 시간 초과의 원인 같음

```jsx
function solution(id_list, report, k) {
		// 1. Set을 사용하여 중복 신고 케이스 제거
    const set = new Set();
    report.forEach((item) => {
        set.add(item);    
    });
    
    // 2. 신고내용 누적, { [신고자]: [신고인, 신고인, ...] }
    const reduced = Array.from(set).reduce((acc, r)=> {
        const [reporter, reportee] = r.split(" ");
        
        return {
            ...acc,
            [reportee]: acc[reportee] ? [...acc[reportee], reporter] : [reporter],
        };
    }, {});

    // 3. id 리스트에서 누적된 신고인 목록들을 조회
    answer = id_list.map((id) => {
        let count = 0;
        // 4. 메일 조건 카운팅
        Object.keys(reduced).forEach((blockedUser) => {
           if (reduced[blockedUser].length > k-1 && reduced[blockedUser].includes(id)) {
               count++;
           }
        });
    
        return count;
    });
    
    return answer;
}
```

### 다른 사람의 풀이1

- 답으로 반환할 배열을 0으로 초기화 하고, 이름과 배열의 인덱스를 맵핑하는 배열을 선언해서 마지막에 값 설정 시 사용
- `||` 를 사용하면 앞에 값이 `NaN` 이거나 `undefined` 인 경우 `||` 뒤에 오는 값으로 설정이 가능

```jsx
function solution(id_list, reports, k) {
    // 1. id 배열 초기화
    var answer = new Array(id_list.length).fill(0);

    // 2. id와 배열 인덱스를 맵으로 사용하기 위해 객체에 저장
    const arrPointer = {};
    id_list.forEach((id, idx) => {
        arrPointer[id] = idx;
    });

    // 3. 중복 내용을 제거하기 위해 id: <신고자>Set 으로 구성된 객체 생성
    const idMap = {};
    id_list.forEach(id => {
        idMap[id] = new Set(); 
    });

    // 4. 신고 내용을 순회하며 id: <신고자>Set에 저장
    reports.forEach(report => {
        const [reporter, cheater] = report.split(" ");
        idMap[reporter].add(cheater);
    });

    // 5. <신고자>Set을 순회하며 신고자들 누적된 값을 reported 맵에 저장
    const reported = {};
    for (const id in idMap) {
        idMap[id].forEach(cheater => {
             reported[cheater] = reported[cheater] + 1 || 1;
        });
    }

    // 6. <신고자>Set 값을 순회하며 reported[신고자]의 값이 k값 이상이면 
    // 신고자 배열 위치에 카운트값 ++
    for (const id in idMap) {
        idMap[id].forEach(cheater => {
            if (reported[cheater] >= k) {
                answer[arrPointer[id]] += 1;
            } 
        });
    }

    return answer;
}
```

### 다른 사람의 풀이2

- reports값을 Set 생성자로 중복 신고 내용을 바로 제거, `[신고자, 신고된 유저]` 튜플값을 갖는 배열로 변환
- 신고내용을 신고된 유저 누적합을 메모이제이션, 신고자 메일 발송 여부를 판단할 때 사용

```jsx
function solution(id_list, reports, k) {
    // 1. 신고된 내역을 Set으로 필터링 후 split으로 나눈 튜플값을 배열로 갖도록 함
    reports = [...new Set(reports)].map(report =>{ return report.split(' ') });

    // 2. 신고 횟수를 저장할 맵 선언 { 신고된유저: 카운트 }
    let reportCnts = new Map();
    // 3. 신고 내용을 순회하며 신고횟수 누적
    for (const report of reports){
        reportCnts.set(report[1], reportCnts.get(report[1]) + 1 || 1);
    }

    // 4. 신고 내용을 순회하며 신고 횟수가 k이상인 경우 메일 발송 조건이면
		//    신고 유저의 메일 발송 횟수를 증가시킴 { 신고한 유저: 메일발송 횟수 }
    let sendMap = new Map(); 
    for(const report of reports){
        if(reportCnts.get(report[1]) >= k){
            sendMap.set(report[0], sendMap.get(report[0]) + 1 || 1);
        }
    }

    // 5. 신고한 유저 맵에서 메일 발송 횟수 추출, 없으면 0으로 설정
    let answer = id_list.map(id => sendMap.get(id) || 0);
    return answer;
}
```

### 개선한 풀이

```jsx
function solution(id_list, reports, k) {
    reports = [...new Set(reports)].map(report => report.split(" "));
    
    const reportedCntMap = new Map();
    for (const [_, blockedId] of reports) {
        reportedCntMap.set(blockedId, reportedCntMap.get(blockedId) + 1 || 1);
    };
    
    const emailSendMap = new Map();
    for (const [reporter, blockedId] of reports) {
        if (reportedCntMap.get(blockedId) >= k) {
            emailSendMap.set(reporter, emailSendMap.get(reporter) + 1 || 1);
        } 
    };

    return id_list.map(id => emailSendMap.get(id) || 0); 
}
```

