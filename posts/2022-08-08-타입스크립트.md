---
title: 타입스크립트 정리 - 클래스, 인터페이스
project: false
date: 2022-08-08
---

### OOP(Object Oriented Programming)

- OOP는 현실의 객체를 속성과 메소드로 구성된 클레스로 만들어 프로그래밍을 하는 패러다임
- `class`는 인스턴스화로 객체를 만들기 위한 청사진

### TS Class

- tsconfig.json `target`에 맞춰 class 내용이 JS로 컴파일됨
- Vanilla JS에선 지원하지 않는 접근지정자(public, private) 기능을 지원

```ts
class Department {
    public name: string; // class field, public은 생략가능
    private employees: string[] = []; // TS는 private 접근지정자(access modifier) 지원

    // 생성자
    constructor(name: string) {
        this.name = name;
    }

    describe(this: Department) {
        console.log("Department: " + this.name);
    }

    addEmployee(employee: string) {
        this.employees.push(employee);
    }

    printEmployeeInformation() {
        console.log(this.employees.length, this.employees);
    }
}
```

- 보통 필드를 선언하고, 생성자에서 필드값을 초기화하는데 **생성자에서 바로 선언과 초기화를 같이 할 수 있음**

```ts
class Department {
    private employees: string[] = []; // TS는 private 접근지정자(modifier) 지원

    // 생성자
    constructor(private id:string, public name: string) {
			// 기존 초기값 할당 내용 생략
    }
```

- TS `readonly` 키워드를 필드 값 할당 시 붙이면 값 변경이 안됨(최초 초기화 시에만 값 설정 가능)

```js
class Department {
    private employees: string[] = []; // TS는 private 접근지정자(modifier) 지원

    // 생성자
    constructor(private readonly id:string, public name: string) {
			//...
    }
```

### 상속

- `extends` 키워드를 이용해서 상속 가능

```ts
class ITDepartment extends Department {
    admins: string[];
    constructor(id: string, admins: string[]) {
        super(id, "IT"); // base class의 생성자를 호출
        this.admins = admins;
    }
}

class AccountingDepartment extends Department {
    constructor(id: string, private reports: string[]) {
        super(id, 'Accounting');
    }
    addReport(text: string) {
        this.reports.push(text);
    }
    printReports() {
        console.log(this.reports);
    }
}
```

- 필요에 따라 부모의 메서드를 **오버라이드** 할 수 있음
    - `private` 속성(필드)는 선언된 클래스 내에서만 참조가 가능함, 상속을 받았을 때도 직접 사용 불가능
    - `protected` 접근지정자는 상속된 경우 확장된 자식 클래스에서도 접근 가능

```ts
class Department {
    protected employees: string[] = [];
...
}

class AccountingDepartment extends Department {
    constructor(id: string, private reports: string[]) {
        super(id, "Accounting");
    }
    addEmployee(name: string): void {
        if (name === "Max") {
            return;
        }
        this.employees.push(name); // employees가 protected 인 경우
    }
...
```

### getter, setter

- getter는 값을 가지고 올 때 함수나 메소드를 실행하는 속성으로 개발자가 좀 더 복잡한 로직을 추가할 수 있게 해줌
    - getter로 private 필드의 값도 가져올 수 있음
    - 속성처럼 `인스턴스.게터명` 으로 사용
- setter는 getter와 쌍으로 구성됨
    - setter는 변수에 값을 할당하는 것과 동일한 방식으로 사용
    

```ts
class AccountingDepartment extends Department {
    private lastReport: string;
    get mostRecentReport() {
        if (this.lastReport) {
            return this.lastReport;
        }
        throw new Error("No Report Found");
    }

    set mostRecentReport(value: string) {
        if (!value) {
            throw Error("Please pass in a valid value!");
        }
        this.addReport(value);
    }
...

const accounting = new AccountingDepartment("d4", []);

// setter 사용
accounting.mostRecentReport = "some report"; 

// getter 사용
console.log(accounting.mostRecentReport);
```

### **정적(static) 메서드 & 속성**

- 정적메서드는 클래스를 기반으로 생서된 객체가 아니라 클래스에서 직접 호출하는 메서드
- `static` 키워드를 붙여 정적 메서드 & 속성을 사용 가능
- 주의할 점은 클래스 내부에서 this로 정적 메서드와 속성은 사용할 수 없음
    - 정적 메서드나 속성을 사용하고 싶으면 `클래스명.정적메소드명` 또는 `클래스명.정적속성명` 을 사용해야 함

```ts
class Department {
    static fiscalYear = 2022;
		...
    constructor(private readonly id: string, public name: string) {
        console.log(Department.fiscalYear);
    }
		
    static createEmployee(name: string) {
        return { name: name };
    }
...

const employee1 = Department.createEmployee("Max");
console.log(employee1);
console.log(Department.fiscalYear);
```

### 추상 클래스

- 특정 클래스의 메소드를 구현하지 않고 상속받는 자식 클래스에서 구현을 강제하고 싶으면 추상 클래스를 사용함
    - 클래스 앞에 `abstract` 가 붙음, 추상 클래스는 인스턴스화를 할 수 없음
    - 추상 클래스에서 자식 클래스에서 구현을 강제하고 싶은 메서드는 추상 메서드로 앞에 `abstract` 키워드를 붙임
        - 구현부는 없어야 하고 매개변수와 리턴타입만 명시함


```ts
abstract class Department {
    ...
    abstract describe(this: Department): void;
...
class ITDepartment extends Department {
    describe(): void {
        console.log("IT Department - ID: " + this.id);
    }
...
class AccountingDepartment extends Department {
    describe(): void {
        console.log("Accounting Department - ID: " + this.id);
    }
...
```

### private 생성자

- "싱글턴 패턴"은 특정 클래스의 인스턴스를 하나만 갖도록 하는 디자인 패턴
- 생성자 앞에 `private` 키워드를 붙이면 `new` 를 사용해서 인스턴스화를 할 수 없게됨
    - 때문에 클래스 내에서만 접근이 가능함 ⇒ 정적 메서드를 이용해서 인스턴스화를 수행
    - static 메서드 내에서 this는 클래스를 참조(일반 메서드는 인스턴스를 참조함)

```ts
class AccountingDepartment extends Department {
    private static instance: AccountingDepartment;
    private lastReport: string;

    private constructor(id: string, private reports: string[]) {
        super(id, "Accounting");
        this.lastReport = reports[0];
    }

    static getInstance() {
        if (AccountingDepartment.instance) {
            return this.instance; // static 메소드 안에선 this로 클래스 자체에 접근 가능
        }
        this.instance = new AccountingDepartment("d2", []);
        return this.instance;
    }
...

const accounting = AccountingDepartment.getInstance();
const accounting2 = AccountingDepartment.getInstance();

console.log(accounting === accounting2); // true
```

### 인터페이스

- 객체의 형태를 설명하는데 사용됨
- 클래스처럼 청사진으로 사용되는게 아니라 사용자 정의 타입으로 사용
    
```ts
interface Person {
    name: string;
    age: number;

    greet(phrase: string): void;
}
    
let user1: Person;

user1 = {
    name: "Young",
    age: 33,
    greet(phrase: string) {
        console.log(phrase + " " + this.name);
    },
};

user1.greet("Hi there I am - ");
```

- `implements` 키워드 뒤에 콤마로 여러개의 인터페이스를 나열해 구현할 수 있음

```ts
interface Greetable {
    name: string;

    greet(phrase: string): void;
}

class Person implements Greetable {
    name: string;
    age = 30;

    constructor(n: string) {
        this.name = n;
    }

    greet(phrase: string): void {
        console.log(phrase + " " + this.name);
    }
}

let user1: Greetable = new Person("Yuong");
user1.greet("Hi there I am - ");
```

- 인터페이스 안에선 public, private 과 같은 접근지정자는 설정할 수 없지만 `readonly` 키워드를 붙여 인터페이스 구현 시 멤버를 한 번 설정하고 값을 바꿀 수 없다는걸 나타낼 수 있음
    
```js
interface Greetable {
    readonly name: string;

    greet(phrase: string): void;
}
...
let user1: Greetable = new Person("Young");
user1.name = "Oh"; // error
```

- 인터페이스도 상속을 통해 확장할 수 있음
    - 클래스와 다르게 인터페이스는 여러 개의 인터페이스를 상속받을 수 있음

```ts
interface Named {
    readonly name: string;
}

interface Greetable extends Named {
    greet(phrase: string): void;
}
```

- 타입처럼 인터페이스를 함수 타입으로 사용 가능
    - 인터페이스 내에 익명함수를 선언하면 됨

```ts
// Type as a Function type
type AddFn = (a: number, b: number) => number;
let add: AddFn;
add = (n1: number, n2: number) => {
    return n1 + n2;
};

// Interface as a Function type
interface AddFn {
    (a: number, b: number): number;
} 
let add: AddFn;
add = (n1: number, n2: number) => {
    return n1 + n2;
};
```

- 선택적 매개변수 & 속성
    - `?` 를 속성 뒤에 붙이면 구현 여부를 optional로 설정가능
    - 속성 뿐만 아니라 메서드도 선택적으로 설정가능

```ts
interface Named {
    readonly name?: string; // optional property
    myMethod?() { ... } // optional method
}
...
class Person implements Named {
    name?: string;
    age = 30;

    constructor(n?: string) { // optional args
        this.name = n;
    }
```

- 인터페이스는 순수하게 개발을 위한 타입스크립트의 기능으로 컴파일로 JS 코드로 변환되지 않음

 
### type? interface?

- 타입스크립트 초기 버전엔 interface가 없었기 때문에 사용자 정의 타입이 호환되게 발전했으나 **객체를 설명하거나 구현하고자 하는 경우 인터페이스를 사용하는게 좋음**


