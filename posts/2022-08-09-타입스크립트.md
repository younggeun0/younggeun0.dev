---
title: 타입스크립트 정리 - 고급타입
project: false
date: 2022-08-09
---

## 인터섹션 타입(Intersection Types)

- `&` 키워드로 다른 타입들을 결합할 수 있음

```ts
type Admin = {
    name: string;
    privileges: string[];
};

type Employee = {
    name: string;
    startDate: Date;
};

type ElevatedEmployee = Admin & Employee;

const e1: ElevatedEmployee = {
    name: "Young",
    privileges: ["create-server"],
    startDate: new Date(),
};
```

- 타입은 인터페이스로도 변경이 가능
    - 다중 상속으로 인터섹션 타입을 구현

```ts
interface Admin {
    name: string;
    privileges: string[];
};

interface Employee {
    name: string;
    startDate: Date;
};

interface ElevatedEmployee extends Admin, Employee { }
```

- 위처럼 객체 타입의 인터섹션은 객체 속성의 조합이 되지만 유니온 타입의 인터섹션은 공통으로 갖는 타입이 됨

```ts
type Combinable = string | number;
type Nemeric = number | boolean;

type Universal = Combinable & Nemeric; // 여기서 Universal === number

const a: Universal = "hi"; // error
const b: Universal = 123; // ok
const c: Universal = true; // error
```

## Type Guards

- 타입가드란 `런타임` 시 특정 타입으로 작업을 수행하기 전에 해당 타입을 검사하는 코드 패턴
    - 유니온 타입이 지닌 유연성을 활용할 수 있게 해줌
1. `typeof` 를 사용한 타입 가드
    - 원시형 타입들의 유니온일 때 사용 가능

```ts
function add(a: Combinable, b: Combinable) {
    // typeof 를 사용한 type guard
    if (typeof a === "string" || typeof b === "string") {
        return a.toString() + b.toString();
    }
    return a + b;
}
```

2. `속성명 in 객체`  을 사용한 타입 가드
    - 객체 타입들의 유니온인 경우 typeof의 결과는 항상 object 이므로 속성이 있는지 여부를 판단해야 함
    - `속성명 in 객체` 를 사용해서 타입가드로 활용

```ts
type UnknownEmployee = Employee | Admin;

function printEmployeeInformation(emp: UnknownEmployee) {
    console.log("Name: " + emp.name);
    if ("privileges" in emp) {
        console.log("Privileges: " + emp.privileges);
    }
    if ("startDate" in emp) {
        console.log("startDate: " + emp.startDate);
    }
}

printEmployeeInformation({ name: "YOung", startDate: new Date() });
```

3. `객체 intanceof 클래스명` 을 사용한 타입 가드
    - `instanceof` 를 사용하면 타입은 모르지만 생성자 함수로 비교하여 타입가드로 쓸 수 있음
    - 단, 인터페이스명엔 instanceof를 쓸 수 없음 ⇒ 인터페이스는 JS코드로 변환되지 않기 때문, 클래스는 생성자 함수로 변환되므로 가능

```ts
class Car {
    drive() {
        console.log("Driving...");
    }
}

class Truck {
    drive() {
        console.log("Driving...");
    }
    loadCargo(amount: number) {
        console.log("Loading cargo..." + amount);
    }
}

type Vehicle = Car | Truck;

const v1 = new Car();
const v2 = new Truck();

function useVehicle(vehicle: Vehicle) {
    vehicle.drive();
    // if ("loadCargo" in vehicle) { // 2. `속성명 in 객체`  을 사용한 타입 가드
    if (vehicle instanceof Truck) { // 3. `객체 intanceof 클래스명` 을 사용한 타입 가드
        vehicle.loadCargo(1000);
    }
}

useVehicle(v1);
useVehicle(v2);
```

## 구별된 유니온(Discriminated Unions)

- 구별된 유니온은 인터페이스에 type 속성으로 `리터럴`을 추가하여 객체를 구분하는 타입가드

```ts
interface Bird {
    type: "bird"; // type이 아닌 literal
    flyingSpeed: number;
}

interface Horse {
    type: "horse";
    runningSpeed: number;
}

type Animal = Bird | Horse;

function moveAnimal(animal: Animal) {
    let speed;
    switch (animal.type) { // 구별된 유니온 type guard
        case "bird":
            speed = animal.flyingSpeed;
            break;
        case "horse":
            speed = animal.runningSpeed;
    }
    console.log("Moving with speed: " + speed);
}

moveAnimal({ type: "bird", flyingSpeed: 1000 });
```

## 형 변환(Type Casting)

- 형 변환은 타입스크립트가 직접 감지하지 못하는 특정 타입의 값을 타입 스크립트에 알려주는 역할을 함, 형 변환은 두 가지 방법이 존재

1. 변수 앞에 `<타입명>`를 붙여 형변환

```tsx
const userInputElement = <HTMLInputElement>document.getElementById("user-input")!;
userInputElement.value = "Hi There";
```

2. 변수 뒤에 `as 타입명` 을 붙여 형변환

```tsx
const userInputElement = document.getElementById("user-input")! as HTMLInputElement;
userInputElement.value = "Hi There";
```

- 엘리먼트가 항상 있다는 보장이 있다면 `!` 을 사용, 보장할 수 없다면 if 조건문으로 처리

```tsx
const userInputElement = document.getElementById("user-input");

if (userInputElement) {
    (userInputElement as HTMLInputElement).value = "Hi There";
}
```

## **Index Types**

- 인터페이스에서 갖는 속성이 하나가 아니고 속성명이 동적인 경우 인덱스 타입을 사용가능
    - 인덱스 타입(속성이 갖는 타입)을 지정하면 여러 속성을 동적으로 추가할 있음

```tsx
interface ErrorContainer
    [prop: string]: string;
}

const errorBag: ErrorContainer = {
    email: "not valid email",
    username: "Must start with...",
};
```

- 단, 인덱스 타입을 갖는 경우 인덱스 타입과 다른 타입의 속성은 추가할 수 없음

```tsx
interface ErrorContainer
    id: string; // ok
    // id: number; // error
    [prop: string]: string;
}
```

## Function Overloads

- 동일한 함수에 대해 여러 함수 시그니처를 정의할 수 있는 기능
- 함수 위에 여러 매개변수 타입과 반환형 타입의 조합을 명시하여 타입스크립트의 타입 추론을 못 할 때 정확히  추론하도록 설정해주는 것

```tsx
function add(a: number, b: number): number
function add(a: string, b: string): string
function add(a: Combinable, b: Combinable) {
    // type guard
    if (typeof a === "string" || typeof b === "string") {
        return a.toString() + b.toString();
    }
    return a + b;
}

const result = add("Max", " Schwarz");
result.split(" ");
console.log(result);
```

## Optional Chaning

- 선택적 체이닝 연산자 `?` 는 객체 데이터의 중첩된 속성과 객체에 안전하게 접근할 수 있게 해줌
    - 속성에 접근하기 전에 존재 여부를 확인하고 없으면 접근하지 않음

```tsx
const fetchedUserData = {
    id: "u1",
    name: "Young",
    job: { title: "CEO", description: "My own company" },
};

// console.log(fetchedUserData.job && fetchedUserData.job.title); // JS 객체여부 체크
console.log(fetchedUserData?.job?.title);
```

  

## Null 병합 (Null Coalescing)

- 패치해온 데이터가 falsy 값인 경우(`””`)  의도치 않게 fallback 값이 설정될 수 있음

```tsx
const userInput = ""; 
const storedData = userInput || "DEFAULT";
console.log(storedData); // "DEFAULT"
```

- Null 병합 연산자 `??` 를 사용하면 null 또는 undefined인 경우에만 fallback 값이 설정됨

```tsx
const userInput = ""; 
const storedData = userInput ?? "DEFAULT";
console.log(storedData); // ""
```
