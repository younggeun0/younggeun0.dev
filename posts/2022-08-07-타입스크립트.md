---
title: 타입스크립트 정리 - 타입스크립트, 기본 타입
tags: [typeScript]
date: 2022-08-07
---

> 타입스크립트 === 자바스크립트 슈퍼셋( 자바스크립트를 기반으로 하는 프로그래밍 언어)

타입스크립트는 브라우저에서 실행 불가
- 타입스크립트는 언어이면서 도구
- 타입스크립트로 작성, 자바스크립트로 컴파일

### 장점
- 새로운 기능과 개발 중 런타임 에러로 인해 발생하는 에러를 초기 개발 과정에서 발견할 수 있도록 도와줌
- 최신 자바스크립트 기능을 사용 가능하고 구형 브라우저에서도 동작 가능한 코드를 제작, 배포 가능
- 타입스크립트 코드들은 자바스크립트로 컴파일할 때 잠재적 에러를 찾는데 사용되고 제거돼 일반 자바스크립트만 출력됨


```js
// tsFile.ts
const button = document.querySelector("button");
const input1 = document.getElementById("num1")! as HTMLInputElement;
const input2 = document.getElementById("num2")! as HTMLInputElement;

function add(num1: number, num2: number) {
	return num1 + num2;
}
button.addEventListener("click", function () {
	console.log(add(+input1.value, +input2.value));
});

// 컴파일된 js파일
var button = document.querySelector("button");
var input1 = document.getElementById("num1");
var input2 = document.getElementById("num2");

function add(num1, num2) {
	return num1 + num2;
}

button.addEventListener("click", function () {
	console.log(add(+input1.value, +input2.value));
});
```


### Core Types

```js
number // 1, 2.5, -10 ...
string // 'Hi'
boolean // true, false
object // { age: 30 }
array // [1,2,3]
tuple // [1,2]
enum // enum { NEW, OLD }
any // *
```

### 타입 추론(Type Inference)

- 타입스크립트는 변수를 선언 시 할당하는 값에 따라 타입을 자동적으로 추론해줌

```js
const age: number = 29; // : number는 명시적으로 타입이 할당돼 있으나 생략 가능
```

- 자바스크립트는 동적 타입을 사용하여 런타임 때 타입 문제가 발견되지만 타입스크립트는 정적 타입을 사용하므로 개발할 때 바로 문제를 알 수 있음
- 일반적으로 object란 타입을 설정하면 프로퍼티에 대한 정보는 알 수 없음, `덕타이핑`을 위해 {} 형식으로 타입 할당을 해줘야 함

```jsx
const person: {
	name: string;
	age: number;
} = {
	name: "young",
	age: 33,
};

console.log(person.name);
```

### Tuple

- 두 개의 다른 타입의 엘리먼트를 갖는 특수한 배열 타입

```js
const person: {
	name: string;
	age: number;
	hobbies: string[];
	role: [number, string]; // tuple
} = {
	name: 'Maximilian',
	age: 30,
	hobbies: ['Sports', 'Cooking'],
	role: [2, 'author']
};
```

###  Enum
- 전역 상수로 사용가능한 커스텀 타입

```jsx
// 일반적인 JS 상수
const ADMIN = 0;
const READ_ONLY = 1;
const AUTHOR = 2;

// TS enum
enum Role {
	ADMIN, READ_ONLY, AUTHOR
};

const person = {
	name: "Maximilian",
	age: 30,
	hobbies: ["Sports", "Cooking"],
	role: Role.ADMIN, // enum
};

// enum의 초기값을 변경하고자 한다면 첫 번째 항목에 시작값을 넣어주면 됨
enum Role { ADMIN = 5, READ_ONLY, AUTHOR }; // READ_ONLY === 6, AUTHOR === 7
// 개별로도 값을 줄 수 있음
enum Role { ADMIN = 5, READ_ONLY = 100, AUTHOR = 200 }; // READ_ONLY === 6, AUTHOR === 7
```

### any

- 컴파일러에서 타입체킹을 생략(Vanila JS와 동일하게 동작)

### 유니온 타입(조합 타입)

- pipe symbol(`|`)로 연결해서 여러 타입이 들어올 수 있게 할 수 있음

```js
function combine(input1: number | string, input2: number | string) {
	let result;
	if (typeof input1 === "number" && typeof input2 === "number") {
        	result = input1 + input2;
	} else {
		result = input1.toString() + input2.toString();
	}
	return result;
}

const combinedAges = combine(100, 3);
console.log(combinedAges);

const combinedNames = combine("Max", "Anna");
console.log(combinedNames);
```

### 리터럴 타입

- const 값에 변수값을 초기 값 할당 시 그 값이 곧 타입이 됨(literal)
- 이 리터럴 타입을 사용해서 특정 값만 받도록 할 수 있음

```js
function combine(
	input1: number | string,
	input2: number | string,
	resultConversion: "as-number" | "as-text" // literal type
) {
	let result;
	if ((typeof input1 === "number" && typeof input2 === "number") ||
		resultConversion === "as-number"
	) {
		result = +input1 + +input2;
	} else {
		result = input1.toString() + input2.toString();
	}
	return result;
}

const combinedAges = combine(100, 3, "as-number");
console.log(combinedAges);

const combinedStringAges = combine("100", "3", "as-number");
console.log(combinedStringAges);

const combinedNames = combine("Max", "Anna", "as-text");
console.log(combinedNames);
```

### 타입 알리어스(사용자 정의 타입)

- 타입 별칭을 사용하면 불필요한 반복을 피하고 코드를 단순화 할 수 있음

```js
// type alias
type Combinable = number | string;

function combine(
	input1: Combinable,
	input2: Combinable,
	resultConversion: "as-number" | "as-text"
) {
...

// type alias
type User = { name: string; age: number };
const u1: User = { name: 'Max', age: 30 };
```

### 함수의 리턴 타입

- 리턴 타입 void - 리턴값이 없는 경우
    - 변수에 타입으로 undefined는 설정 가능하나 함수엔 사용 불가
    - void인 경우 함수 호출 시 undefined가 반환됨

```js
function printResult(num: number): void {
    console.log("Result: " + num);
}
```

### 함수 타입

- 함수의 매개변수 및 반환 타입을 정의하는 함수 타입
- 변수에 함수를 할당할 경우 타입으로 Function 타입을 설정할 수 있음
    - 그러나 Function 타입 사용 시 어떤 함수든 들어갈 수 있음

```js
let combinedValues: Function;
```

- 함수의 인자와 반환값을 표현한 화살표 함수로 함수 타입을 설정하면 특정 함수를 타입으로 사용 가능

```js
function add(n1: number, n2: number) {
    return n1 + n2;
}

let combinedValues: (a: number, b: number) => number;

combinedValues = add;
console.log(combinedValues(8, 8));
```

### 함수 타입 및 콜백

- 인자로 콜백함수를 설정할 수 있음

```jsx
function addAndHandle(n1: number, n2: number, cb: (num: number) => void) {
    const result = n1 + n2;
    cb(result);
}

addAndHandle(10, 20, (result) => {
    console.log(result);
});
```

- 콜백 함수는 자신이 전달되는 인수가 반환되는 값을 기대하지 않는 경우에도 값을 반환할 수 있음

```js
function sendRequest(data: string, cb: (response: any) => void) {
  // ... sending a request with "data"
  return cb({data: 'Hi there!'});
}
 
sendRequest('Send this!', (response) => { 
  console.log(response);
  return true;
 });
```

### unknown 타입

- unknown 타입은 아무 값이나 할당 가능
    - any와 다르게 타입은 모르지만 타입 체킹은 수행함

```jsx
let userInput: any;
let userName: string;

userInput = 5;
userInput = "Max";

userName = userInput;

if (typeof userInput === "string") {
    userName = userInput;
}
```

### never 타입

- never 타입은 반환값이 없을 때 사용

```jsx
function generateError(msg: string, code: number): never {
    throw { message: MessageChannel, errorCode: code };
}

const result = generateError("An error occurred", 500);
console.log(result);
```


